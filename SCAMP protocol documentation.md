SCAMP Service Oriented Architecture

[[TOC]]

# Overview

The SCAMP Service Oriented Architecture (henceforth, SOA) is a shared bus which connects users of modules to their implementations.  It provides the following features:

* **Modularity** - API-accessible components can be written in any language and run on any machine in the network

* **Discovery** - Components which are run will automatically be picked up; there is no need to change web-server configuration files

* **Reusability** - SOA is not limited to the Web server; any component can make requests to any other component

* **Redundancy** - multiple instances of components can run, allowing increased performance through load-balancing and increased reliability

* **Security** - data is encrypted on all communications, no operations are performed without a capability token, and cryptographic authorization is required to run services.

The SOA system is comprised of a number of subsystems, which are described in the following sections.

# Glossary

* **action** A single named API call, such as Config.Vendor.list; in general, a *version* is needed to completely specify the call.

* **announcement packet** A byte string generated by a *service instance* to describe its offerings to passers-by.

* **authentication **Verifying that a connection is coming from a specific identity.

* **authorization** Checking that a principal has some capability.

* **basename** Portion of an *action* after the last dot; see also *class*.

* **class** Portion of an *action* before the last dot.  May contain dots!  See also *basename*.

* **discovery** The process by which a *requester* learns that a *service instance* exists and what *action*s the instance provides.

* **dispatcher** A special *requester* which is also a web server, allowing properly-authorized AJAX applications to avail themselves of SOA.

* **requester** Any component in the system which wishes to make use of the functionality provided by *service*s.

* **service** Either *service program* or *service instance*, depending on context.

* **service instance** The smallest externally addressable unit of implementation, typically a single tree of processes on a single machine.

* **service program** The program which implements a *service instance*; note that several can share one program, if the instance is replicated.

* **version** A positive integer which, together with an *action*, specifies a method to call.  Versions default to 1 if not specified.

# Unified configuration

All components of the SOA system proper in all languages are configured by a soa.conf file containing key/value pairs, as described in CONFIG.md

# Discovery

In order to inform potential requesters, each service instance publishes an announcement packet at periodic intervals, by default 5 seconds.  These announcement packets contain information on the actions and versions provided by the service and how to access them.

The format of announcement packets may change in the future, in a compatible or incompatible way.  This section contains recommendations for error handling which will maximize future compatibility.

## Packet envelope format

Each packet consists of a string of bytes representing characters.  These bytes SHOULD be regarded as being UTF-8 encodings of characters; however, characters outside the ASCII range MUST at this time not be used.  The packet is broken up into sections separated by consecutive pairs of NL characters (U+000A U+000A); there will not in general be a trailing separator.  The first three sections are, in order, a data packet, a signing certificate, and a signature.  Readers SHOULD ignore additional sections on the end.  Sections obviously MUST not contain the separator string (U+000A U+000A); additionally the packet MUST not contain the string \n%%%\n, used in the section "File distribution" below.

## Packet data format

The first section of an announce packet is a string encoded in JSON containing the content of the announcement.  This section SHOULD be encoded in such a way that it contains no characters outside the range U+20 to U+7E, for instance by the ->pretty(0)->ascii options of Perl’s JSON::XS module.

The packet, after JSON decoding, is an array of the following items:

<table>
  <tr>
    <td>Index</td>
    <td>Mnemonic</td>
    <td>Description</td>
  </tr>
  <tr>
    <td>0</td>
    <td>version</td>
    <td>Version number for the format.  Currently MUST be 2.</td>
  </tr>
  <tr>
    <td>1</td>
    <td>ident</td>
    <td>A unique string for this service instance.  SHOULD be the Base64 representation of 18 random bytes chosen at startup.</td>
  </tr>
  <tr>
    <td>2</td>
    <td>weight</td>
    <td>Currently unused, SHOULD be 1.  Intended to reflect the current load factor of the service instance, for use with load balancing.</td>
  </tr>
  <tr>
    <td>3</td>
    <td>send_interval</td>
    <td>How often this service instance broadcasts announcements, in milliseconds between announcements.  Typically 5000.</td>
  </tr>
  <tr>
    <td>4</td>
    <td>address</td>
    <td>A URI for connecting to the service.  See section "Communication".</td>
  </tr>
  <tr>
    <td>5</td>
    <td>envelopes</td>
    <td>Array of strings giving supported envelope formats, e.g. ["json","extdirect"].   See section “Envelope formats”.</td>
  </tr>
  <tr>
    <td>6</td>
    <td>classes</td>
    <td>Offered actions, broken down by class.  See below.</td>
  </tr>
  <tr>
    <td>7</td>
    <td>timestamp</td>
    <td>MUST be a monotonically increasing number used to prevent replay attacks.  SHOULD be fractional seconds since the Epoch as returned by gettimeofday(2).</td>
  </tr>
</table>


To reduce size, the action list is broken down by class.  The "classes" entry is an array of class records.  Each class record is an array of one or more items; the first item in a class record is the class name, each subsequent item is an action description.  An action description is a three-element array of the action name, the CRUD tags as a comma-separated string, and the version number.

CRUD tags are used by the Web dispatcher to service *.jsonstore requests; see the section "[Web dispatcher](#bookmark=id.dsi0hz9hyjuc)" for details.

Putting it all together, here is a simple example of the data portion of an announcement packet, with whitespace and Javascript comments (NOT legal in the actual wire format!) added for readability:

[

	2,	// version number

	"",	// service instance identifier - random

	1,	// default weight

	3500,	// 3.5 second interval

	"scamp+tls://10.0.0.42:31349",

		// should be accessible from any host in the network

	["json","extdirect","jsonstore"],

		// this service supports all currently defined envelopes

	[

		// provides A.foo and A.bar version 1

		// A.bar will be used by the web dispatcher to support

		// create and update JsonStore actions

		[ "A", [ "foo", "", 1 ],

		       [ **"**bar", "create,update", 1 ] ],

		// also provides B.C.quux - note that everything before

		// the last dot is part of the class

		// note that each version which is provided must be listed

		// individually.  B.C.quux version 1 is not implemented by

		// this service, but another service could offer it

		[ "B.C", [ "quux", "", 3 ],

		         [ "quux", "", 2 ] ]

	],

	1352443012.88785 // 2012-11-08

]

## Signatures and service authorization

The second section of the announcement packet must be a signing certificate represented by an X.509 [Certificate structure](https://tools.ietf.org/html/rfc5280#section-4.1).  This structure must be encoded using ASN.1 DER, Base64-encoded, and bracketed by -----BEGIN CERTIFICATE----- and -----END CERTIFICATE----- lines.  This is known as "pem" format in OpenSSL.  It is expected that a future version of this specification will use SOA-specific certificate extensions along with a known root CA to authorize certificates, however at this time authorization must be explicitly configured; see the configuration documentation above.  At this time the certificate’s subjectPublicKey MUST be an RSA public key as defined by PKCS#1.

The third section of the announcement packet is a Base64-encoded RSA signature, created using PKCS#1 v1.5 padding over a SHA-256 hash of the announcement data packet, as encoded on the wire, not including the trailing the trailing separator.  In most cases this byte string will end with the ASCII value for a ] character.

Receivers MUST NOT accept an announcement packet as valid unless it carries a valid signature.  Moreover, the certificate MUST be checked to ensure it belongs to the configured list of acceptable certificates, and offered actions which are not listed in the certificate metadata MUST NOT be used.

Receivers MUST track the highest timestamp value seen so far for a given certificate, and ignore any received announcement with a lower timestamp, as it may be a malicious replay.  Receivers MUST also save the certificates received, as they will be needed during the communication step.

## Multicast distribution

A service which is running will send announcements at the interval indicated to a multicast datagram socket using UDP, to the multicast group configured by discovery.bus_address on the port configured by discovery.bus_port.  When a service wishes to shut down, it SHOULD send announcements indicating a lack of available services at least three times.  However, since a service may shut down without warning, for instance in cases of hardware failure, a receiver MUST disregard announcements which were not refreshed recently; it is RECOMMENDED that a validity period of 2.1 times the send_interval be adopted.

## File distribution

For the benefit of requesters which must begin making requests less than 5 seconds after startup, an additional method is provided.  A scoreboard file exists with a name determined by the discovery.cache_path variable.  This file contains all of the current most recent announcements in an arbitrary order, each preceded by the marker string U+0A % % % U+0A.  Before the first such marker is arbitrary data which readers MUST ignore.

The updater is a separate daemon, implemented by js/script/cache_updater.js in the scamp repository.

# Communications

Once a requester has decided which service provides the action it needs, the requester needs to make the actual call.  This is done by sending a **request** and then waiting for a **reply**.

If the call fails for a reason not related to internal SOA problems, an **error reply** will be returned, containing a short **error code** and a human-readable (English) **error message**.  Error codes are currently underused, but they will become invaluable when we approach internationalization.  The RetailOps AJAX client attaches special significance to two error codes: **authn** is taken to indicate an expired session and causes a redirect to the login page, while **authz** is displayed as a lack-of-privileges error.

## Message concept

Requests and replies use a common representation called a message.  A message consists of a short JSON packet called a **header** followed by an arbitrary-length byte string **body**.

Headers must be transmitted as a unit.  They are encoded as JSON hashes and have a limited set of fields:

<table>
  <tr>
    <td>action</td>
    <td>request</td>
    <td>The full action name, e.g. Customer.Order.create</td>
  </tr>
  <tr>
    <td>envelope</td>
    <td>request</td>
    <td>String identifying the envelope format, e.g. json</td>
  </tr>
  <tr>
    <td>error</td>
    <td>reply</td>
    <td>Human readable error if present</td>
  </tr>
  <tr>
    <td>error_code</td>
    <td>reply</td>
    <td>Error code if present</td>
  </tr>
  <tr>
    <td>message_id</td>
    <td>both</td>
    <td>String used to correlate requests to responses in the event of reordering.  RECOMMENDED 18 random bytes base64-encoded.</td>
  </tr>
  <tr>
    <td>station</td>
    <td>request</td>
    <td>A station ticket, see Ticket format.  Optional</td>
  </tr>
  <tr>
    <td>ticket</td>
    <td>request</td>
    <td>An authorization ticket, see Ticket format.  Optional</td>
  </tr>
  <tr>
    <td>type</td>
    <td>both</td>
    <td>request or reply</td>
  </tr>
  <tr>
    <td>version</td>
    <td>request</td>
    <td>Action version number</td>
  </tr>
</table>


The body is transferred as a lazy string of frames and has a format defined by the selected envelope format.  It can end either normally or abnormally.  Abnormal ends are used to indicate infrastructural error conditions such as losing the connection during transmission; they are associated with an error message.  Error replies have the error and error_code fields set, and an empty body.  Error replies and abnormal ends are not the same, although they should be handled the same whenever feasible.

## Envelope formats

Envelope formats are one of the more hackish parts of SOA.  They define the formatting of the body parts of messages, both requests and replies, and provide some mapping to the underlying programming languages.  Due to idiosyncratic handling at the programming language level, they must be handled at the service end, but the web requester also needs awareness in order to correctly convert errors into presentable ones.

### json envelope

This envelope format is used by the web requester for *.json URLs.  Request and reply objects are simply encoded in JSON.

### jsonstore envelope

This envelope format is used for the special needs of Sencha’s stores, and BOY ARE THEY SPECIAL.  Some of these needs are taken care of by the web dispatcher and are described in the web dispatcher’s section below.  Requests and replies are JSON-encoded and generally are hashes with a **records** field containing a list of data records.  Requests have an **xaction** field of create, read, update, or delete.  If xaction is read, then the reply is additionally expected to have a **metaData** field containing information about the format which Sencha requires.  The Perl library automatically populates metaData on the basis of POD comments in the source code.

## SCAMP protocol

The only protocol currently supported for the communication subsystem is a regrettably custom one called "SCAMP" and identified by the URI scheme “scamp+tls://”.  It is closely based on the Blocks Extensible Exchange Protocol ([BEEP](http://www.beepcore.org/)), but since no suitable implementations for BEEP were available at the time of writing in Javascript or Perl, a tweaked subset was implemented.

A SCAMP connection is symmetrical after connection, insofar as messages can be sent in either direction.  However, as it is used in SOA, the connecting party is the requester and sends requests, while the accepting party only sends replies and sends exactly one reply for each request it receives.

### Packet encoding

A SCAMP conversation can be broken down into a stream of packets sent by each party.  A packet is a short (typically below 64 KiB) atomic transmission with a defined boundary.  A packet is sent as a string of octets "*type* 20 *msgno* 20 *length* 0D 0A *body* ‘E’ ‘N’ ‘D’ 0D 0A".  This format is completely fixed: the header fields must be separated by exactly one space, the trailer must be capitalized, the newlines must be CRLF.  *type* is an ASCII string identifying the type of packet; *msgno* is a type-dependant ASCII decimal nonnegative integer identifying the message to which this packet belongs; *length* is the length of the body in octets; and *body* is the body itself, raw.

The following packet types are defined:

* A **HEADER** packet is sent first when a message is transmitted.  It contains in its body the JSON-encoded message header.  A HEADER packet must always be the first (non-ACK) packet sent with a given message number, and the message number used must be one greater than that used by the last HEADER packet, or 0 for the first such packet.

* **DATA** packets are sent for the message body.  The message number must correspond to a HEADER packet which has already been sent, and no **TXERR** or **EOF** packet may have previously been sent for that message number.  The message body may be split into any number of pieces at any point, although message senders MUST NOT send empty **DATA** packets and MUST NOT send **DATA** packets larger than 128 KiB.

* **EOF** and **TXERR** packets are sent to mark the end of a message.  Every message sent MUST end with exactly one of these packets, and other packets MUST NOT be sent after the **EOF** or **TXERR**.  **EOF** packets must have an empty body and are used to signal normal termination; abnormal termination is signalled by a **TXERR** packet with the error message in its body.

* **ACK** packets are sent for flow control, and MUST contain a single decimal integer without trailing newline in their body.  Unlike the other defined packet types, the message number in an **ACK** packet refers to the *opposing* message stream. 

### Flow control

To avoid overloading buffers on the receiving end, senders SHOULD NOT send more than flow.max_inflight (default 65536) bytes of data before receiving an acknowledgement.  Acknowledgement packets carry an acknowledged data pointer, which is the total count of bytes in the current message which the receiver wishes to have acknowledged.  This is a strictly increasing count.  If 1000 bytes have already been acknowledged, and the receiver wishes to indicate acceptance of one more byte, it sends an **ACK** packet with body 1001.

There is some ambiguity in the definition of accepted data.  In general, a receiver should accept a byte when that byte moves out of anything which would be considered an intermediate buffer.  So transferral of the byte into a kernel socket send buffer would ideally not be considered acceptance, but writing the byte into a buffer which is intended to accept an entire message before use would be.  Use your best judgement.

### Differences from BEEP

The following known differences from BEEP exist; they are all deliberate decisions, but may be reversed in the future if it becomes desirable to leverage an existing BEEP client library.

* BEEP defines TLS negotiation after connection setup using a <starttls/> element.  SCAMP expects TLS negotiation during connection setup, a la HTTPS.

* BEEP requires explicit negotiation of channels.  SCAMP starts with a single channel, which behaves as an [RFC 5573](https://www.rfc-editor.org/rfc/rfc5573.txt) asynchronous channel.  (Lack of support for asynchronous channels was the #1 reason the Javascript and Perl BEEP client libraries were rejected.)

* BEEP ACK packets have a special form distinct from other packets and lacking a trailer.  SCAMP ACK packets use the regular form.

* While SCAMP messages are divided into a header, body, and optional error trailer, BEEP messages are undifferentiated streams of bytes.

* On the other hand, BEEP has internal support for request/response correlation and divides messages into MSG, RPY, ERR, and ANS categories, SCAMP does not and treats them all the same.

* BEEP allows the final data block of a message and the end indication to be combined into a single packet using an end indication field in the packet header.  SCAMP does not.

* BEEP requires a count of bytes-so-far in the packet header.  SCAMP omits it.

* BEEP has an explicit procedure for orderly shutdown.  SCAMP does not, and relies on the termination of messages to detect disordered connection shutdown.

## Security

SCAMP connections are always conducted over TLS to provide confidentiality and integrity guarantees.  However, TLS does not by itself guarantee that you are talking to the correct server and not an imposter; this must be done, with some help from TLS, by higher-level protocols.

The approach adopted for SOA is to compare the TLS server certificate with the certificate used to sign the corresponding announcement.  If they are the same, then the server is judged to be legitimate and is trusted to the same extent that the announcement was (which may not be complete trust).  Note that, since we use a configuration file to determine authorized certificates, it is not necessary to have a certificate from a well-known CA to host a SOA server; self-signed will do fine.

It’s really irritating that the TLS suite does not offer a single post-quantum secure key agreement scheme or signature scheme (unless you count [a single Internet-Draft](https://tools.ietf.org/id/draft-ietf-tls-ntru-00.txt) which was never implemented and expired ten years ago).

# Authentication and authorization

As part of SOA’s generally defensive design, services do not automatically trust requesters to do anything they want.  The requester must, in general, demonstrate that it corresponds to some recognized identity (**authentication**) and that said identity is permitted to do the requested action (**authorization**).  This is done by presenting tickets, in a manner quite similar to Kerberos.

## Ticket format

Three kinds of ticket are used in the SCAMP SOA system.  **Authentication ticket**s prove that the bearer represents a specific user, and contain basic information about the user.  **Authorization ticket**s additionally contain a list of privileges granted to the user.  **Station ticket**s last forever and are used to signify that the bearing machine has access rights.  All kinds of ticket are represented as comma-separated strings, with the following components, in order:

* Type number.  1 for authentication and authorization tickets (distinguished by presence of a privilege list), 2 for station tickets.  All other values are currently illegal.

* User (or station) ID, in decimal.

* Client ID, in decimal.

* Beginning of validity period, as a decimal integer UNIX time.  Not used with stations.

* Length of validity period, decimal integer seconds.  Not used with stations.

* List of privileges, as decimal integers separated by + characters.  Only present in authz tickets.

* (Always last) [Base64-URL](https://en.wikipedia.org/wiki/Base64#URL_applications) encoded DSA signature of the preceding items, not including the , before the signature.  The public key used is configured globally.

## Authorizations

Auth tickets must be generated by an authorizing party. This would generally be implemented as a noauth flagged action under one of your services.

# Perl library

The Perl library for SOA, in scamp/perl, is used to support the main Perl service and the auth service.  It provides an EV-based server and a blocking requester, and uses Moose throughout.  It consists of core services (Config, Logger, Message) that are used throughout; Discovery, which creates, sends, receives, and parses announcements; a SCAMP implementation; and a requester.  The following modules exist:

<table>
  <tr>
    <td>SCAMP::Config</td>
    <td>Parses the master /etc/SCAMP/soa.conf file and provides access to it.</td>
  </tr>
  <tr>
    <td>SCAMP::Discovery::Announcer</td>
    <td>EV-based task for cryptographically signing and sending multicast packets at regular intervals.</td>
  </tr>
  <tr>
    <td>SCAMP::Discovery::ServiceInfo</td>
    <td>Represents a received announcement in the requester.</td>
  </tr>
  <tr>
    <td>SCAMP::Discovery::ServiceManager</td>
    <td>Tracks all ServiceInfo objects used in the requester.</td>
  </tr>
  <tr>
    <td>SCAMP::Logger</td>
    <td>Neatly formats debug messages for output.  In the future, may be fancier.</td>
  </tr>
  <tr>
    <td>SCAMP::Message</td>
    <td>Implements the basic message abstraction, used to carry data between application logic and the transport layer.</td>
  </tr>
  <tr>
    <td>SCAMP::Requester</td>
    <td>Simple requester.  Exposes a non-EV-based API (but uses EV internally) and uses file access for announcements, could be extended to handle the long-running EV case.</td>
  </tr>
  <tr>
    <td>SCAMP::Transport::SCAMP::Client</td>
    <td>Initiates requests to SCAMP servers.  Correlates requests and responses, issues timeout errors. </td>
  </tr>
  <tr>
    <td>SCAMP::Transport::SCAMP::Connection</td>
    <td>Core logic for the SCAMP protocol.</td>
  </tr>
  <tr>
    <td>SCAMP::Transport::SCAMP::Server</td>
    <td>Accepts requests as a SCAMP server.</td>
  </tr>
  <tr>
    <td>SCAMP::Transport::ConnectionManager</td>
    <td>Tracks active connections for the requester.</td>
  </tr>
</table>


# Javascript library

The Javascript library is primarily used for the Web dispatcher.  It is based on the Node.js framework and heavily leverages asynchrony.  Like the Perl library, it can be roughly divided into framework, discovery, protocol, and wrapper sections:

<table>
  <tr>
    <td>lib/actor/requester.js</td>
    <td>High-level request logic.</td>
  </tr>
  <tr>
    <td>lib/actor/service.js</td>
    <td>High-level logic for services.</td>
  </tr>
  <tr>
    <td>lib/discovery/announce.js</td>
    <td>Formats and distributes announcements.</td>
  </tr>
  <tr>
    <td>lib/discovery/observe.js</td>
    <td>Receives multicast announcements, updates serviceMgr.</td>
  </tr>
  <tr>
    <td>lib/handle/Message.js</td>
    <td>Implements core message abstraction.</td>
  </tr>
  <tr>
    <td>lib/handle/service.js</td>
    <td>Represents a single announced instance.</td>
  </tr>
  <tr>
    <td>lib/index.js</td>
    <td>Top-level service locator.</td>
  </tr>
  <tr>
    <td>lib/transport/scamp/client.js</td>
    <td>Connect to SCAMP services, run cryptographic binding, correlate requests and responses, generate timeouts.</td>
  </tr>
  <tr>
    <td>lib/transport/scamp/connection.js</td>
    <td>SCAMP core logic.</td>
  </tr>
  <tr>
    <td>lib/util/config.js</td>
    <td>Parse and provide access to master config file</td>
  </tr>
  <tr>
    <td>lib/util/connectionMgr.js</td>
    <td>Track open connections for reuse</td>
  </tr>
  <tr>
    <td>lib/util/DripStream.js</td>
    <td>Utility to send data at a controlled rate to node</td>
  </tr>
  <tr>
    <td>lib/util/serviceMgr.js</td>
    <td>Track services announced to requester</td>
  </tr>
</table>


The Javascript library repository also contains several tools of independent utility:

<table>
  <tr>
    <td>script/cache-manager.js</td>
    <td>See section "Updater daemon"</td>
  </tr>
  <tr>
    <td>script/monitor-announce.js</td>
    <td>Real-time spy on multicast traffic</td>
  </tr>
  <tr>
    <td>script/request.js</td>
    <td>Generate requests by hand</td>
  </tr>
  <tr>
    <td>script/testservice.js</td>
    <td>Example Javascript service</td>
  </tr>
</table>


# Web dispatcher

The web dispatcher is a special requester which is also a http server.  It allows external API clients to access SOA services. It lives in the dispatcher/ directory.

The web dispatcher is separated loosely into two sections.  The "emitter" in lib/emit is charged with brokering requests safely into the SOA system; it collects proper tickets, sanity checks authentication and authorization, and enforces quotas.  The “frontend” in server.js is more concerned with the HTTP interface, and implements the high-level quirks of interfacing with API clients.

# Updater daemon

The updater daemon, which lives in js/script/cache-manager.js in the scamp repository, is responsible for listening to multicast announcements and relaying them to the announcement file.  Additionally, it does some pre-verification of announcements to check signatures and basic formatting.

